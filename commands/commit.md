# Commit Command

- 누적된 변경사항을 적절히 나누어 커밋합니다.

## 커밋 메시지 규칙

1. **Conventional Commits** 형식 사용
2. **모든 메시지는 한국어로 간결히 작성**
3. **커밋 메시지는 한 줄로만 작성** (제목만, 본문 없음)
4. **커밋 설명(description/body)은 절대 작성하지 않음**

### 형식

```
<타입>: <설명>
```

### 타입

- `feat:` - 새로운 기능 추가 (대부분의 경우)
- `fix:` - 버그 수정
- `refactor:` - 코드 리팩토링 (기능 변경 없이 구현만 변경)
- `chore:` - 빌드, 설정 파일 등 유지보수 작업 및 기타 사소한 변경
- `style:` - 코드 포맷팅, 세미콜론 추가 등 (코드 동작 변경 없음)
- `docs:` - 문서 수정
- `test:` - 테스트 코드 추가 또는 수정

### 예시

```
feat: shadcn field 컴포넌트 추가
fix: false 값이 엑셀에서 올바르게 표현되지 않는 문제 수정
refactor: 이미지 정보 필드를 추가 정보 필드로 변경
chore: gitignore 업데이트
style: prettier 적용
```

## 실행 방법

**IMPORTANT**: 반드시 다음 순서를 따라야 합니다.
변경사항이 크다면 **여러 커밋으로 분할하는 것을 기본값으로** 합니다.
모든 커밋은 최대한 세분화하여 커밋합니다. 같은 파일의 변경사항도 여러 커밋으로 나눌 수 있습니다. 일괄 변경이 아니라면 변경사항을 하나의 커밋을 묶는 것을 지양하세요.

0. **현재 브랜치/워크스페이스 확인**
   - `git branch --show-current` 로 현재 브랜치 확인
   - (워크트리 사용 시) `pwd` 로 작업 폴더가 맞는지 확인

1. **변경사항 파악**
   - `git status` 로 변경 파일 목록 확인
   - `git diff` 로 실제 변경 내용 확인

2. **커밋 단위 설계(분할 계획)**
   - 각 단위가 **독립적으로 이해/리뷰 가능하도록** 나눔
   - 변경사항 및 현재까지의 대화를 참고하여, **논리적 단위(기능/버그/리팩터/스타일/문서/테스트 등)** 로 나눌 수 있는지 판단.
   - **(중요)** 같은 파일에서의 변경사항이더라도, 타입이 다른 경우 다른 커밋으로 분할하여 처리 (ex: A 메서드는 변경, B 메서드는 신규 구현)
   - **(중요)** 다른 파일에서의 변경사항이더라도, 작업 단위가 같은 경우 같은 커밋으로 병합하여 처리 (ex: 메서드 이름 일괄 변경). 단, 병합은 필요한 경우 아니라면 최대한 지양.

3. **[반복] 첫 번째 커밋 단위부터 스테이징**
   - 해당 단위에 속하는 변경만 스테이징
   - 필요 시 **부분 스테이징** 사용: `git add -p`
   - 스테이징 후 `git diff --staged` 로 **현재 커밋에 들어갈 내용만** 재확인

4. **한 줄 커밋 메시지 생성**
   - 위 규칙에 따라 `<타입>: <설명>` 형태로 **한국어로 간결히** 작성
   - 본문/설명 절대 금지

5. **git commit 실행**
   - `git commit -m "<타입>: <설명>"`

6. **[반복] 남은 변경사항에 대해 3~5단계를 반복**
   - `git status` 로 남은 변경 확인
   - 다음 커밋 단위를 스테이징 → 메시지 생성 → 커밋
   - **변경사항이 모두 커밋될 때까지 반복**

7. **최종 확인**
   - `git status` 가 clean 인지 확인
   - 필요하면 `git log --oneline -n <개수>` 로 커밋 분할이 의도대로 되었는지 점검

